/**
 *	\file
 */

#pragma once

#include <atomic>
#include <cstdint>
#include <type_traits>
#include <utility>

namespace mcpp {

/**
 *	A helper class which allows the lifetimes
 *	of continuations and objects those continuations
 *	wish to access to be reconciled.
 *
 *	By passing wrapped versions (created by calling
 *	the \ref wrap member function) as continuations
 *	to the initiating functions for asynchronous
 *	operations one is assured that those wrapped
 *	functions will not be invoked beyond the return
 *	from a call to \ref stop. That is to say a return
 *	from \ref stop:
 *
 *	-	Synchronizes with the return from any continuation
 *		which was actually invoked (i.e. the return from
 *		the continuation happens before the return from
 *		\ref stop)
 *	-	Precludes the invocation of any further continuation
 *		(i.e. once the synchronizes with relationship
 *		detailed above is established it is the case that
 *		no further continuations created by a call to
 *		\ref wrap will be invoked)
 *
 *	These assurances are provided by minimal overhead
 *	checks and operations performed in the wrapper
 *	generated by the \ref wrap member. If the checks
 *	determines that \ref stop has been called the
 *	wrapped function is simply not invoked.
 *
 *	Note that copy operations for this class have
 *	reference semantics (i.e. all copies of an async
 *	object refer to the same underlying state).
 */
class async {
private:
	class pointer {
	private:
		std::atomic<std::uint64_t> * ptr_;
		void destroy () noexcept;
		void acquire () noexcept;
	public:
		pointer ();
		pointer (const pointer &) noexcept;
		pointer (pointer &&) noexcept;
		pointer & operator = (const pointer &) noexcept;
		pointer & operator = (pointer &&) noexcept;
		~pointer () noexcept;
		void complete () noexcept;
		//	If returns false complete does not
		//	need to be called
		bool invoke () noexcept;
		void stop () noexcept;
		bool stopped () const noexcept;
	};
	pointer ptr_;
	template <typename F>
	static constexpr bool nothrow = std::is_nothrow_constructible<std::decay_t<F>, F &&>::value &&
		std::is_nothrow_move_constructible<std::decay_t<F>>::value;
public:
	async () = default;
	async (const async &) = default;
	async (async &&) = default;
	async & operator = (const async &) = default;
	async & operator = (async &&) = default;
	/**
	 *	Cleans up the object.
	 *
	 *	If this is the last reference to the underlying
	 *	state and \ref stop has not been called the
	 *	behavior is undefined.
	 */
	~async () noexcept;
	/**
	 *	Wraps a callable object such that no call to
	 *	that object may occur past the return from
	 *	\ref stop.
	 *
	 *	\tparam F
	 *		The type of callable object to wrap.
	 *
	 *	\param [in] func
	 *		The callable object to wrap.
	 *
	 *	\return
	 *		A function object which takes the same
	 *		arguments as \em func and which returns
	 *		void regardless of what \em func returns.
	 */
	template <typename F>
	auto wrap (F && func) noexcept(nothrow<F>) {
		pointer local(ptr_);
		return [ptr = std::move(local), f = std::forward<F>(func)] (auto &&... args) mutable {
			if (!ptr.invoke()) return;
			try {
				f();
			} catch (...) {
				ptr.complete();
				throw;
			}
			ptr.complete();
		};
	}
	/**
	 *	Ensures that no further continuations
	 *	will be run and waits for all currently
	 *	running continuations to complete.
	 *
	 *	If this is called from within a continuation
	 *	the behavior is undefined.
	 *
	 *	If this method is not called before
	 *	the last reference to the underlying state
	 *	is released the behavior is undefined.
	 */
	void stop () noexcept;
};

}
